# Турнирная таблица для кикера

Основная идея - отслеживание счета текущей игры, составление таблицы результатов и рейтинг команд. Приложение состоит из двух частей, серверной на `NodeJS` и front-end части.

## Серверная часть

Полный список методов на сервеной части:

method | url                           | params    | Result
------ | ----------------------------- | --------- | ----------
GET    | /game/start                   | _idTable_ | token or 0
GET    | /game/%token%/goal            | _id_      | 1 or 0
GET    | /game/%token%/reset           |           | 1 or 0
GET    | /game/%token%/cancel          |           | 1 or 0
GET    | /game/%token%/change-position |           | 1 or 0

Каждый метод (кроме start), который сделан для самого стола кнопок и датчиков должен возвращать либо `1` в случае успешного запроса либо `0` если произошла ошибка

### /game/start

Первый метод, который будет вызываться при старте игры - `127.0.0.1:3000/game/start`, который будет возвращать `token` новой игры и текущего стола, это необходимо для корректной привязки счета к игре. Для определения стола мы будем передавать параметр `idTable`.

### /game/%token%/goal

Мы предполагаем, что у кикерного стола будут датчики, которые отслеживают попадание меча в ворота. После попадания мы будем вызывать url `127.0.0.1:3000/game/%token%/goal` и передавать `id` ворот `0 или 1`. Так же стоит учесть, что матч (а не игра) завершается когда команда первой забивает 10 голов. Необходимо учесть что последний гол может быть спорным и отменен.

### /game/%token%/cancel

Часто бывают спорные голы, поэтому так же неоходим метод `127.0.0.1:3000/game/%token%/cancel` который будет отменять последний забитый гол.

### /game/%token%/change-position

Игра в кикер состоит из двух матчей, или из 3х если первые два сыграны в ничью. После каждой игры команды меняются местами, синие начинают играть за красных, а красные за синих. Поэтому мы будем вызывать метод `127.0.0.1:3000/game/%token%/change-position` для когда наступает время смены мест.

### /game/%token%/reset

Дополнительно к столу мы добавим кнопку сброса. Которая будет вызывать метод `127.0.0.1:3000/game/%token%/reset` который будет сбрасывать текущий результат игры

> новая игра всегда будет начинаться с нажатия кнопки и `никогда через интерфейс`.

На этом часть работы именно с датчиками и контроллерами закончена. Дальше будут описаны методы которые вам потребуется реализовать, и которые будут необходимы для работы с клиентской частью. Данные необходимые для выполнения запроса на ваш выбор так же, как и ответ на эти запросы.

### Для работы с командами игроков

method | url                   | description
------ | --------------------- | ------------------------------------------
GET    | /commands             | список команд
GET    | /commands/%commandId% | получить информацию о определенной команде
POST   | /commands/%commandId% | создать команду
DELETE | /commands/%commandId% | Удалить команду
PUT    | /commands/%commandId% | Обновить информацию о команде

### Для работы со статистикой и счетами

method | url                | description
------ | ------------------ | ------------------------------------------------
GET    | /score             | Общая статистика по всем командам
GET    | /score/%commandId% | Получить статистику игр для определенной команды

Если вам понадобятся другие методы не стесняйтесь их добавлять.

## Клиентская часть

На стороне клиента необходимо реализовать функционал:

- Отображение всех игр для конкретного стола;
- Добавление и редактирование команд, у команды будет название, и цвет с которого они начинают, красный или синий;
- Список всех команд с возможностью удалить или отредактировать команду;
- Выбор команд и стола для следующией игры;
- `Сброс` текущего счета;
- Смена команд местами и `обнуление` счета;
- Отмена гола;
- Турнирная таблица с возможностью посмотреть определенную команду, когда и с кем играла;

[Пример первого экрана приложения](https://monosnap.com/file/oEwotf0CQWi3t5LTgFYF7SB13qBK5v.png)

Страница с текущим матчем. Вам необходимо будет реализовать старинцу с командами и страницу с статистикой. Этот макет служит только в качестве примера, если у вас есть идеи как сделать лучше - делайте!

## Технологии

Данные на сервере можно хранить в `текстовом файле`, [mongoDb](https://www.mongodb.com/) или любой другой форме или базе данных. mongoDB возможно будет ближе и понятнее.

Возможно на первом этапе решить не делать серверную часть и воспользоваться такими сервисами как [Apiary](https://apiary.io/), [Canned](https://github.com/sideshowcoder/canned), [Mockable](https://www.mockable.io/) или [Mocky](http://www.mocky.io/)

Для создания серверного приложения можно взять [KoaJs](http://koajs.com/) или [ExpressJs](http://expressjs.com/)

Для реализации клиентской части можно посмотреть в стороны [backboneJs](http://backbonejs.org/), [knockoutJs](http://knockoutjs.com/), [ReactJs](https://facebook.github.io/react/)

## Примечание

Для эмуляции работы датчика устройств или кнопок - используйте бразуер.

Если вам необходима какая то графика, или вас интересует как эффективнее построить работу приложения - обращайтесь к любому из нас!